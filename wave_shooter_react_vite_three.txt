/*
Wave Shooter - Starter (single-file project scaffold + run instructions)

Files included below as separate sections. Copy each into your project.

Dependencies (recommended):
  - react, react-dom
  - vite
  - three
  - @react-three/fiber
  - @react-three/drei (optional, used for easy helpers)

Commands to create project quickly:
  npm create vite@latest wave-shooter -- --template react
  cd wave-shooter
  npm install three @react-three/fiber @react-three/drei
  Replace src/main.jsx and src/App.jsx with the files below.
  npm run dev

--- package.json (only if you want a ready example) ---
{
  "name": "wave-shooter",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "three": "^0.156.0",
    "@react-three/fiber": "^8.12.0",
    "@react-three/drei": "^9.52.0"
  },
  "devDependencies": {
    "vite": "^5.0.0"
  }
}

--- src/main.jsx ---
import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './styles.css'

createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

--- src/styles.css ---
:root { --bg: #0b1020; --ui: #111827; --accent: #22c55e; --danger: #ef4444 }
html,body,#root{height:100%;margin:0;padding:0;background:var(--bg);color:#fff;font-family:Inter, system-ui, Arial}
.canvas-wrap{width:100vw;height:100vh;display:flex}
.ui{position:absolute;left:16px;top:16px;background:rgba(0,0,0,0.45);padding:12px;border-radius:8px}
.hud{position:absolute;right:16px;top:16px;background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;text-align:right}
.button{background:#111;padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
.small{font-size:13px}

/* basic crosshair */
.crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none}
.crosshair:before{content:'';display:block;width:18px;height:18px;border:2px solid rgba(255,255,255,0.6);border-radius:50%}

--- src/App.jsx ---
import React, { useRef, useState, useEffect, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { OrbitControls, Stats } from '@react-three/drei'
import * as THREE from 'three'

// GAME CONSTANTS
const PLAYER_SPEED = 6
const ENEMY_SPEED = 1.6
const BOSS_SPEED = 0.9
const WAVE_INTERVAL = 2000 // ms between waves spawning

// Utility: random position on plane
function randPos(range = 18) {
  const x = (Math.random() - 0.5) * range * 2
  const z = (Math.random() - 0.5) * range * 2
  return [x, 0.5, z]
}

// Player (simple rectangle box) with WASD movement
function Player({ position, setPositionRef, healthRef }) {
  const ref = useRef()
  const vel = useRef([0, 0, 0])
  useEffect(() => {
    const keys = { w: false, a: false, s: false, d: false }
    function down(e) {
      const k = e.key.toLowerCase()
      if (k in keys) keys[k] = true
    }
    function up(e) {
      const k = e.key.toLowerCase()
      if (k in keys) keys[k] = false
    }
    window.addEventListener('keydown', down)
    window.addEventListener('keyup', up)
    const id = setInterval(() => {
      const dir = [0, 0, 0]
      if (keys.w) dir[2] -= 1
      if (keys.s) dir[2] += 1
      if (keys.a) dir[0] -= 1
      if (keys.d) dir[0] += 1
      const len = Math.hypot(dir[0], dir[2]) || 1
      ref.current.position.x += (dir[0] / len) * (PLAYER_SPEED * 0.1)
      ref.current.position.z += (dir[2] / len) * (PLAYER_SPEED * 0.1)
      // clamp
      ref.current.position.x = Math.max(Math.min(ref.current.position.x, 40), -40)
      ref.current.position.z = Math.max(Math.min(ref.current.position.z, 40), -40)
      setPositionRef(ref.current.position)
    }, 16)
    return () => {
      window.removeEventListener('keydown', down)
      window.removeEventListener('keyup', up)
      clearInterval(id)
    }
  }, [setPositionRef])

  // small pulsing animation
  useFrame((_, dt) => {
    if (ref.current) {
      ref.current.rotation.y += dt * 0.3
    }
  })

  return (
    <mesh ref={ref} position={position} castShadow>
      <boxGeometry args={[1.8, 0.8, 1.2]} />
      <meshStandardMaterial color={0x22c55e} metalness={0.2} roughness={0.6} />
    </mesh>
  )
}

// Enemy minion (sphere)
function Minion({ id, pos, playerPosRef, onDie, isBoss=false }) {
  const ref = useRef()
  const speed = isBoss ? BOSS_SPEED : ENEMY_SPEED
  useFrame((_, dt) => {
    if (!ref.current) return
    const dir = new THREE.Vector3()
    dir.subVectors(playerPosRef.current, ref.current.position)
    const dist = dir.length()
    if (dist > 0.6) {
      dir.normalize()
      ref.current.position.addScaledVector(dir, speed * dt)
    }
    // simple collision check
    if (dist < 1.2) {
      // hit player
      onDie(id, true)
    }
  })
  return (
    <mesh ref={ref} position={pos}>
      {isBoss ? (
        // hexagon: cylinder with 6 sides
        <cylinderGeometry args={[1.6, 1.6, 0.8, 6]} />
      ) : (
        <sphereGeometry args={[0.6, 16, 16]} />
      )}
      <meshStandardMaterial color={isBoss ? 0xffb020 : 0xff0055} />
    </mesh>
  )
}

// Triangle boss (every 3 waves). Use cylinder with 3 radial segments
function TriangleBoss({ id, pos, playerPosRef, onDie }) {
  const ref = useRef()
  useFrame((_, dt) => {
    if (!ref.current) return
    const dir = new THREE.Vector3()
    dir.subVectors(playerPosRef.current, ref.current.position)
    const dist = dir.length()
    if (dist > 0.8) {
      dir.normalize()
      ref.current.position.addScaledVector(dir, BOSS_SPEED * dt * 1.3)
    }
    if (dist < 1.4) onDie(id, true)
  })
  return (
    <mesh ref={ref} position={pos} rotation={[Math.PI / 2, 0, 0]}>
      <cylinderGeometry args={[2.2, 2.2, 0.9, 3]} />
      <meshStandardMaterial color={0x8b5cf6} />
    </mesh>
  )
}

// Pickup is a small box that floats
function Pickup({ pos, type, onCollect, id }) {
  const ref = useRef()
  useFrame((_, dt) => {
    if (!ref.current) return
    ref.current.rotation.y += dt
    ref.current.position.y = 0.8 + Math.sin(performance.now() / 300 + id) * 0.15
  })
  return (
    <mesh ref={ref} position={pos} onClick={() => onCollect(id)}>
      <boxGeometry args={[0.5, 0.5, 0.5]} />
      <meshStandardMaterial color={type === 'health' ? 0x22c55e : 0x60a5fa} />
    </mesh>
  )
}

export default function App() {
  // game state
  const [playerPos, setPlayerPos] = useState([0, 0, 0])
  const playerPosRef = useRef(new THREE.Vector3(0, 0, 0))
  const setPositionRef = (pos) => { playerPosRef.current.copy(pos); setPlayerPos([pos.x, pos.y, pos.z]) }
  const [enemies, setEnemies] = useState([]) // {id, pos, isBoss}
  const [pickups, setPickups] = useState([])
  const [wave, setWave] = useState(0)
  const [score, setScore] = useState(0)
  const [health, setHealth] = useState(100)
  const enemyId = useRef(1)
  const pickupId = useRef(1)
  const waveTimer = useRef(null)

  // spawn a wave of N enemies
  function spawnWave(number = 6) {
    setWave(w => w + 1)
    const isTriangle = ((wave + 1) % 3 === 0)
    const newEnemies = []
    for (let i = 0; i < number; i++) {
      const id = enemyId.current++
      const pos = randPos(30)
      newEnemies.push({ id, pos, isBoss: Math.random() < 0.12 })
    }
    // every 3 waves add triangle boss
    if (isTriangle) {
      const id = enemyId.current++
      newEnemies.push({ id, pos: randPos(30), isTriangle: true })
    }
    setEnemies(prev => [...prev, ...newEnemies])
  }

  // spawn random pickup
  function spawnPickup(type = 'power') {
    const id = pickupId.current++
    setPickups(p => [...p, { id, pos: randPos(30), type }])
  }

  // start waves loop
  useEffect(() => {
    spawnWave(4)
    waveTimer.current = setInterval(() => {
      spawnWave(4 + Math.floor(wave / 2))
      // random pickups occasionally
      if (Math.random() < 0.5) spawnPickup(Math.random() < 0.5 ? 'health' : 'power')
    }, 12000)
    return () => clearInterval(waveTimer.current)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // handle enemy death or collision
  function onEnemyDie(id, hitPlayer=false) {
    setEnemies(prev => prev.filter(e => e.id !== id))
    if (hitPlayer) {
      setHealth(h => Math.max(h - 12, 0))
    } else {
      setScore(s => s + 10)
      // small chance to drop pickup
      if (Math.random() < 0.25) spawnPickup(Math.random() < 0.6 ? 'power' : 'health')
    }
  }

  function onPickupCollect(id) {
    const p = pickups.find(pk => pk.id === id)
    if (!p) return
    setPickups(prev => prev.filter(pk => pk.id !== id))
    if (p.type === 'health') setHealth(h => Math.min(h + 25, 100))
    else {
      // power-ups: simple temporary effect - e.g., increase speed or double score
      setScore(s => s + 50)
    }
  }

  // game over watch
  useEffect(() => {
    if (health <= 0) {
      // reset minimal game state
      setEnemies([])
      setPickups([])
      setWave(0)
    }
  }, [health])

  // ground plane grid material
  const grid = useMemo(() => new THREE.GridHelper(200, 40, 0x222831, 0x121212), [])

  return (
    <div className="canvas-wrap">
      <Canvas shadows camera={{ position: [0, 35, 30], fov: 50 }}>
        <ambientLight intensity={0.6} />
        <directionalLight position={[10, 40, 10]} intensity={0.8} castShadow />
        <primitive object={grid} position={[0, 0, 0]} />

        <Player position={[0, 0.5, 0]} setPositionRef={(pos) => setPositionRef(pos)} />

        {enemies.map(e => (
          e.isTriangle ? (
            <TriangleBoss key={e.id} id={e.id} pos={e.pos} playerPosRef={playerPosRef} onDie={onEnemyDie} />
          ) : (
            <Minion key={e.id} id={e.id} pos={e.pos} playerPosRef={playerPosRef} onDie={onEnemyDie} isBoss={e.isBoss} />
          )
        ))}

        {pickups.map(p => (
          <Pickup key={p.id} id={p.id} pos={p.pos} type={p.type} onCollect={onPickupCollect} />
        ))}

        <OrbitControls enableRotate={false} enablePan={false} maxPolarAngle={Math.PI / 2.2} minPolarAngle={Math.PI / 3} />
        <Stats />
      </Canvas>

      <div className="crosshair" />

      <div className="ui">
        <div className="small">Wave: <strong>{wave}</strong></div>
        <div className="small">Score: <strong>{score}</strong></div>
        <div className="small">Health: <strong>{health}</strong></div>
        <div style={{height:8}} />
        <button className="button" onClick={() => { setEnemies([]); setPickups([]); setHealth(100); setScore(0); setWave(0) }}>Restart</button>
        <div style={{height:6}} />
        <div className="small">Controls: WASD to move</div>
      </div>

      <div className="hud small">
        <div>Enemies: {enemies.length}</div>
        <div>Pickups: {pickups.length}</div>
      </div>

    </div>
  )
}

/*
Notes & next steps:
 - This is a minimal starter scaffold focusing on gameplay mechanics, not optimized.
 - You can replace shapes with textured meshes, add bullet shooting, collision layers, pooling
 - Tweak spawn logic and tune speeds, sizes, and frequencies
 - Add audio and particle effects using drei's helpers or three.js directly
*/
